/*
 *  --------------------------------------------------------------------------------------------
 *
 *    VVV        VVV A           Virtual Acoustics (VA) | http://www.virtualacoustics.org
 *     VVV      VVV AAA          Licensed under the Apache License, Version 2.0
 *      VVV    VVV   AAA
 *       VVV  VVV     AAA        Copyright 2015-2022
 *        VVVVVV       AAA       Institute of Technical Acoustics (ITA)
 *         VVVV         AAA      RWTH Aachen University
 *
 *  --------------------------------------------------------------------------------------------
 */

#include "VASequencerSignalSource.h"

#ifdef VACORE_WITH_SAMPLER_SUPPORT

#	include "../VAAudiostreamTracker.h"

#	include <ITAException.h>
#	include <ITASoundSamplePool.h>
#	include <ITASoundSampler.h>
#	include <sstream>

CVASequencerSignalSource::CVASequencerSignalSource( const double dSamplerate, const int iBlocklength )
    : m_pAssociatedCore( nullptr )
    , m_pSampler( nullptr )
    , m_pSamplePool( nullptr )
{
	m_pSamplePool = ITASoundSamplePool::Create( 1, dSamplerate );

	m_pSampler = ITASoundSampler::Create( 1, dSamplerate, iBlocklength, m_pSamplePool );
	m_iTrackID = m_pSampler->AddMonoTrack( );
}

CVASequencerSignalSource::~CVASequencerSignalSource( )
{
	delete m_pSamplePool;
	delete m_pSampler;
}

int CVASequencerSignalSource::GetType( ) const
{
	return IVAAudioSignalSource::VA_SS_SEQUENCER;
}

std::string CVASequencerSignalSource::GetTypeString( ) const
{
	return "sequencer";
}

std::string CVASequencerSignalSource::GetTypeMnemonic( ) const
{
	return "seq";
}

std::string CVASequencerSignalSource::GetDesc( ) const
{
	return std::string( "Plays an audio signal generated by sampling (sound synthesis)" );
}

std::string CVASequencerSignalSource::GetStateString( ) const
{
	return "<TODO: State string>";
}

IVAInterface* CVASequencerSignalSource::GetAssociatedCore( ) const
{
	return m_pAssociatedCore;
}

int CVASequencerSignalSource::AddSoundPlayback( int iSoundID, int, double dTimecode )
{
	/*
	const ITASoundSample* pSample = m_pSamplePool->GetSample(iSoundID, true);
	if (pSample == nullptr)
	VA_EXCEPT2(INVALID_PARAMETER, "Invalid sound ID");
	*/

	return m_pSampler->AddPlaybackByTimecode( iSoundID, m_iTrackID, dTimecode );
}

std::vector<const float*> CVASequencerSignalSource::GetStreamBlock( const CVAAudiostreamState* pStreamInfo )
{
	// [fwe] Dieser Cast ist in Ordnung. VACore-intern wird immer CVAAudioStreamStateImpl weitergeleitet
	const float* pfData = m_pSampler->GetBlockPointer( 0, dynamic_cast<const CVAAudiostreamStateImpl*>( pStreamInfo ) );
	m_pSampler->IncrementBlockPointer( );
	return { pfData };
}

void CVASequencerSignalSource::HandleRegistration( IVAInterface* pParentCore )
{
	m_pAssociatedCore = pParentCore;
}

void CVASequencerSignalSource::HandleUnregistration( IVAInterface* )
{
	m_pAssociatedCore = nullptr;
}

#endif // VACORE_WITH_SAMPLER_SUPPORT
